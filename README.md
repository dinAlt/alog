# Alog

Результат выполнения тестового задания для MOST.

## Версия Go

Используемая версия го - 1.18 (обратная совместимость с 1.17 сломана только использованием `any` вместо `interface{}`)

## Сборка тестовой утилиты

```bash
go build -o alog_test main.go
```

## Использование

```bash
./alog_test

Usage:
  ./alog_test <NUM_PROCS> <NUM_RECORDS>

Flags:
  -bench-std
    	also bench std log
  -capacity int
    	capacity of log channel (default 500)
  -h	print this help message

```

## Предположения по заданию

Из описания задачи можно сделать вывод, что структурное логирование реализовывать не требуется (так как используется пакет log). Также, я не стал занимать оптимизацией io и выделения памяти.

Поскольку указано, что можно ограничиться одним уровнем логирования, я реализовал только метод `Printf`, сигнатура которого соответствует одноименному методу пакета log. Это может облегчить переход на новый логер, если стандартный используется как структура а не через вызов функций самого пакета.

## Примечания

Док комменты написаны на ломаном английском, не был уверен на каком языке писать, по-этому сделал как привык.

Реализация основана на использовании буферизированного канала. Емкость (по-умолчанию - 500) может быть изменена опцией конструктора `WithCapacity` (флаг утилиты -capacity). Производительность напрямую зависит от того, забивается ли буфер канала.

Соответственно, хотя даже на небуферизированном канале результаты на моей машине получаются лучше, чем со стандартным логером, данное решение наиболее эффективно в ситуации, когда в приложении могут быть кратковременные пиковые нагрузки, а долгосрочная нагрузка не заполняет буфер канала полностью.

Также, стоит отметить, что буферизированный вывод накладывает определенную ответственность на пользователя пакета. Он должен позаботиться о том, чтобы метод `Stop` вызывался даже при аварийной остановке программы (например, с использованием `defer` и `recover`).

## Результаты тестов

Тестовая машина: CPU: MD Ryzen 5 2600 Six-Core Processor, Memory: 32Gb, OS: ArchLinux (5.18.14-arch1-1)

Вот результаты нескольких прогонов на моей машине с разными входными значениями.

```
./alog_test -bench-std -capacity 5000 5 500
...
Custom logger: goroutines done in: 957.442µs
Custom logger: done in: 11.549904ms
Std log: done in: 9.66024ms

==============================================

./alog_test -bench-std -capacity 100 5 500
...
Custom logger: goroutines done in: 9.505683ms
Custom logger: done in: 9.669584ms
Std log: done in: 8.556628ms

==============================================


./alog_test -bench-std -capacity 0 12 500
...
Custom logger: goroutines done in: 21.872636ms
Custom logger: done in: 22.467277ms
Std log: done in: 36.57818ms

```

Результаты бенчмарка стандартными средствами Go не прилагаю. Они показывают, что если убрать тяжелое io - штатная реализация логгера на мьютексах оказывается в 3-5 раз быстрее чем выделение отдельной горутины, даже с использованием буферизации.

## Дальнейшие усовершенствования

Наиболее очевидные точки оптимизации для меня:

- Оптимизация io (возможно стоит поиграться с размером буфера `bufio.Writer`, особенно актуально при логирование в файл)
- Оптимизация выделения памяти (например, использование пула bytes.Buffer для работы со строками)
- Оптимизация работы со строками (отказ от методов fmt, использующих reflect).
- Возможно, распараллеливание записи используя несколько потребителей также даст прирост в производительности (не актуально при записи в стандартные потоки io и в файл, однако может помочь при логировании напрямую во внешнюю систему вроде `loki`)

Из улучшений в юзабилити - можно реализовать структурное логирование.

## Итог

Данное решение, скорее всего, действительно даст прирост к производительности при условиях, указанных в задании, и при достаточном размере буфера канала. Однако, если оптимизировать выделение памяти, io, и работу со строками (как это сделано в промышленных логерах) - останутся затраты на синхронизацию (и я не вижу возможности от них избавится) и на передачу данных между горутинами (если вернуться к стандартной схеме без использования отдельного воркера).
